作法：
用靜態分析的方法打開檔案後，仔細讀完Aseembly 的邏輯跟做法可以知道執行檔的行為如下：
1. 從使用者端讀取FLAG，透過FLAG 的每個字元建構一個Link list，順序為0 -> n -> n - 1-> n - 2 -> .... -> 1。
2. 接著會對每格幾個Index 做XOR 的動作，透過存取FLAG 上面的另外一個陣列，裡面存了一些數值。
3. 透過XOR 完就是一層一層比對FLAG 轉變過的結構內存的值是否等於執行黨內存的值。

遇到的問題：
1. 記憶體讀取的位置，因為在判斷的位置是一次存一個bytes，v4 那個位置卻是讀16bits 的兩個bytes 的值，所以等於一次讀兩個值。
2. condition 的位置只有改過一次，所以FLAG 存的位置很特別，要特別處理。
3. HIBYTE, LOBYTES 分別指前1個byte, 後1個byte，這個東西會跟v4有關，v4 一次讀兩個bytes 的東西出來。